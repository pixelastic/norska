import EventEmitter from 'events';
import config from 'norska-config';
import firost from 'firost';
import helper from 'norska-helper';
import webpackDevConfig from './webpack.dev.config.js';
import webpackProdConfig from './webpack.prod.config.js';
import webpack from 'webpack';
import { _, pify, chalk } from 'golgoth';

export default {
  /**
   * Default configuration object
   * @returns {object} Default module config
   **/
  defaultConfig() {
    return {
      input: 'script.js',
      output: 'script.js',
    };
  },
  /**
   * Return the correct Webpack config object
   * Note: The config is slightly different if we're building for production or
   * for dev (dev is faster), and it also correctly set the input and ouput
   * field based on what is defined in the configuration
   * @returns {object} Webpack configuration object
   **/
  async loadConfig() {
    let baseConfig;
    let outputFilename = config.get('js.output');
    if (helper.isProduction()) {
      baseConfig = webpackProdConfig;
      outputFilename = _.replace(outputFilename, '.js', '.[hash].js');
    } else {
      baseConfig = webpackDevConfig;
    }
    const webpackConfig = _.merge({}, baseConfig, {
      entry: config.fromPath(config.get('js.input')),
      output: {
        path: config.to(),
        filename: outputFilename,
      },
    });
    // Check that entry file exists, and fail early if it does not
    const entryFile = _.get(webpackConfig, 'entry', null);
    if (!(await firost.exist(entryFile))) {
      return false;
    }
    return webpackConfig;
  },
  /**
   * Return a webpack instance with .run() and .watch() methods
   * Note: It will promisify the .run and .watch methods
   * @returns {boolean|object} False if config is invalid, Webpack object
   * otherwise
   **/
  async getCompiler() {
    if (this.__compiler) {
      return this.__compiler;
    }
    const webpackConfig = await this.loadConfig();
    if (!webpackConfig) {
      return false;
    }

    const compiler = this.__webpack(webpackConfig);
    compiler.run = this.__pify(compiler.run.bind(compiler));
    this.__compiler = compiler;
    return compiler;
  },
  /**
   * Returns a recap of the compilation including time elapsed
   * @param {object} stats Stats object, as returned by webpack
   * @returns {string} Readable output stats
   **/
  getOutputStats(stats) {
    const time = stats.endTime - stats.startTime;
    return `JavaScript compiled in ${time}ms`;
  },
  /**
   * Return list of js files generated by webpack
   * @param {object} stats Stats returned from Webpack
   * @returns {Array} List of generated js files
   **/
  getEntrypointsFromStats(stats) {
    return _.chain(stats.toJson())
      .get('entrypoints.main.assets')
      .filter(item => {
        return _.endsWith(item, '.js');
      })
      .value();
  },
  errorMessage(stats) {
    return _.chain(stats.toJson())
      .get('errors')
      .nth(0)
      .split('\n')
      .reject(line => {
        return (
          _.startsWith(line, 'Module build failed') ||
          _.startsWith(line, '    at ')
        );
      })
      .join('\n')
      .value();
  },
  /**
   * Build the output js file once
   * @returns {boolean} True if compilation worked, false otherwise
   **/
  async run() {
    const progress = firost.spinner();
    progress.tick('Compiling JavaScript');
    const compiler = await this.getCompiler();
    if (!compiler) {
      progress.success('JavaScript compilation skipped');
      return false;
    }

    const stats = await compiler.run();
    if (stats.hasErrors()) {
      const errorMessage = this.errorMessage(stats);
      progress.failure('JavaScript compilation failed');
      throw firost.error('ERROR_JS_COMPILATION_FAILED', errorMessage);
    }

    const jsFiles = this.getEntrypointsFromStats(stats);
    config.set('runtime.jsFiles', jsFiles);
    const outputStats = this.getOutputStats(stats);
    progress.success(outputStats);
  },
  /**
   * Run webpack and listen for dev changes
   * @returns {Event} Event emitter firing 'error' and 'build' events
   **/
  async watch() {
    const compiler = await this.getCompiler();
    if (!compiler) {
      return false;
    }

    this.__watcher = compiler.watch({}, (err, stats) => {
      if (stats.hasErrors()) {
        this.pulse.emit('buildError', stats);
        const errorMessage = this.errorMessage(stats);
        firost.consoleError(chalk.red(errorMessage));
        return;
      }

      // Update list of runtime files so we can reload the HTML
      config.set('runtime.jsFiles', this.getEntrypointsFromStats(stats));

      firost.consoleSuccess(this.getOutputStats(stats));
      this.pulse.emit('build', stats);
    });
  },
  /**
   * Stop watching for file changes
   * Note: This is very useful in tests to prevent the watch to run forever
   **/
  async unwatch() {
    await this.__watcher.close();
  },
  /**
   * Webpack watcher instance, to be able to call .unwatch() to stop watching
   * (used in tests)
   **/
  __watcher: null,
  /**
   * Compiler cache
   **/
  __compiler: null,
  /**
   * Wrapper around webpack(), to make it easier to mock in tests
   * @param {object} config Webpack config
   * @returns {object} Webpack compiler
   **/
  __webpack: webpack,
  /**
   * Wrapper around pify(), to make it easier to mock in tests
   * @param {Function} method Method to promisify
   * @returns {Function} Promisified method
   **/
  __pify: pify,
  /**
   * Event emitter to emit/listen to events
   **/
  pulse: new EventEmitter(),
};
